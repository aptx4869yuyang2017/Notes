---
up: 
related: 
year: 2023
created: 2024-08-21
tags:
  - domain/powerbi
type: "[[Book📚]]"
ch: "00"
finished: 
aliases:
---

> [!NOTE]- 目录
> ![738addce94f844219c1caf98f4945b91|309](https://s1.vika.cn/space/2024/08/22/738addce94f844219c1caf98f4945b91)



# 每章介绍



- CH07 理解 DAX 公式引擎
	- **FE执行查询计划采用的算法**
	- 数据缓存/物化/回掉 等相关概念，更深入理解了 FE如何与 SE 协作互动
	- 不同的 SE 会产生完全不同的 查询计划
	- 融合 是一种 FE 优化技术
	- 思考 FE 执行方式执行过程的思路
		- 先自己思考 FE 会如何设计查询计划
		- 再查看实际的查询计划，对比和自己预想的差异
	- 需要留意的 FE 特性
		- 单线程：优化 FE 通常是关键
		- 执行的 SE 查询通常有先后顺序
		- FE 没有缓存：执行步骤不缓存，设计 callback 也没缓存
	- 分析查询计划时间
		- 总时间/SE CPU 时间
		- FE 时间 / SE 时间
		- SE 查询数量 / 集中 SE 缓存的数量
- CH08 理解查询计划
	- **详细解释 物理查询计划/逻辑查询计划**  CH07 的自然延伸
	- 查询计划结构




[[优化DAX-CH08-理解查询计划]]
[[优化DAX-CH09 优化FE]]
[[优化DAX-CH10-理解VertiPaq]]


# CH01 介绍

## 附带内容


### 下载数据



[Contoso sample databases· GitHub](https://github.com/sql-bi/Contoso-Data-Generator-V2-data/releases/tag/ready-to-use-data)



# CH02 案例介绍优化方案

### 3 优化混合模型

- 复合模型如何影响优化过程
- 问题不在于 DAX 代码，而在于 local 与 remote 引擎的交互
- 为了优化性能
	- 对架构又深入的理解
	- 及远程服务器与本地服务器的查询分配方式



[Dynamic segmentation – DAX Patterns](https://www.daxpatterns.com/dynamic-segmentation/)



# CH03 介绍 Tabular 模型查询架构

### 数据孤岛与跨岛查询


![](https://s1.vika.cn/space/2024/08/21/4923283e8c524993a68705f461016fc9)


- Product / Sales 存在远程的 AS 模型上，也就是 DQ over AS
- Customer DQ over SQL
- Date VertiPaq


![](https://s1.vika.cn/space/2024/08/21/6cb03dea0569479f991bb61c6fd40c9a)


![775109ddfd30417ab52d93beb7c417ca|468](https://s1.vika.cn/space/2024/08/21/775109ddfd30417ab52d93beb7c417ca)

- 解决思路：
	- 因为分别的岛屿并不知道其他岛屿的信息，所以只能在关联粒度上查询数据，最后让 FE 进行处理
- 问题
	- 服务器之间有大量的数据移动，例如 CustomerKey 包含的值远比 Continent 多

![6be5ebff509f481dac23dbde0473af44|589](https://s1.vika.cn/space/2024/08/21/6be5ebff509f481dac23dbde0473af44)

- 实际方案：
	- 把 Customer / Date 两个岛屿， 聚合维度 - 键  查询出来
	- 传给 remote 的有 Sales 的岛屿处理


# CH07 理解 DAX 公式引擎 FE


### 理解 datacaches


- **公式引擎和存储引擎的分工**：在执行DAX查询时，任务会在公式引擎和存储引擎之间分配。不同的查询细微变化可能会导致截然不同的查询计划。例如，如果一个公式是可加性的（additive），那么总计是由公式引擎计算的；如果公式是不可加性的（non-additive），那么存储引擎会通过额外的查询来计算这些值。
    
- **公式引擎不直接访问数据**：公式引擎永远不会直接访问数据，它只处理数据缓存。查询的执行速度与数据缓存的大小密切相关：缓存越小，查询速度越快。
    
- **数据缓存的大小与查询复杂性相关**：数据缓存中包含的行数取决于查询的复杂性。有时，数据缓存的大小是最小的，这种情况下执行速度最优。然而，有些情况下数据缓存的大小可能超出所需，这会影响执行速度。在这种情况下，**需要学习如何减少数据缓存的大小，以减少在两个引擎之间传输数据缓存的工作量，从而提高查询性能**。


--- 

> [!NOTE]
> 
> 1. **单次查询与并行执行**：计算引擎通常一次只向VertiPaq存储引擎发送一个查询。而对于SQL的DirectQuery，可以并行执行多个存储引擎查询。但即使如此，并行执行的查询数量通常也仅限于一个小的个位数。
>     
> 2. **复杂查询与简单查询的并行化**：在存储引擎内，一个复杂的查询可以被并行化处理，与此同时，得到相同结果的多个简单查询可能需要依次执行，或者在最好的情况下只能有限度地并行化。这意味着，如果查询被分成很多小块，整体效率反而可能会降低。
>     
> 3. **最优算法**：无论使用哪种存储引擎，最优的算法通常是由少量复杂的存储引擎查询组成，然后由计算引擎进行最后的处理。这样做的目的是最小化计算引擎和存储引擎之间的通信开销，从而提高整体效率。
> 


### 理解 物化

- 其实就是存储引擎的查询结果需要被存在内存中的情况。
- 是因为不仅需要消耗数据，还需要在内存中存储数据以供后续使用。因此，物化增加了系统的内存和处理开销


### 理解 回掉

![](https://s1.vika.cn/space/2024/08/22/bc589dd91b2340eebe4750ef2da781e8)

- 只发生在存储引擎是 VertiPaq 的场景，因为很多函数功能 VertiPaq 没有，为了避免大型的物化，所以给了 VertiPaq 调用 公式引擎的能力
- 虽然公式引擎是单线程的，但是每个 VertiPaq 线程都会对应一个独立的公式引擎，所以性能的损耗主要还是来自引擎通信的开销



### 融合

- FE内的优化技术，可以减少SE的查询次数
- 垂直融合 Vertical Fusion
	- 相同的筛选上下文，计算多个度量值
	- 物理查询计划 Spool_Iterator - Cache
- 水平融合 Horizontal Fusion
	- 不同的筛选上下文，计算同一个度量值（不要求同一个度量）
	- 物理查询计划  DataPostFilter



![67d504d76e794e4f958ac6fcbcf3846c|415](https://s1.vika.cn/space/2024/08/24/67d504d76e794e4f958ac6fcbcf3846c)

![78dc0a055cf04dd3b63cfd6c44787dde|423](https://s1.vika.cn/space/2024/08/24/78dc0a055cf04dd3b63cfd6c44787dde)



![](https://s1.vika.cn/space/2024/08/24/b9a6f63f0a73480d97dd0962f36527ff)

- 物理查询计划
	- 高亮的行是 `Extend_Lookup` 操作符，它执行的是两个表达式之间的除法运算
	- 3 ～ 5 行之间，公式引擎检索了蓝色产品的销售金额
	- 6 ～ 8 行之间，检索了红色产品的销售金额

![49bd653507e848b9b11d8305d957201d|165](https://s1.vika.cn/space/2024/08/24/49bd653507e848b9b11d8305d957201d)



